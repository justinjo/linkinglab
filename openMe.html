<!DOCTYPE html>
<html>
<head>
	<script lang="javascript" src="js/jquery-3.1.0.min.js"></script>
	<script lang="javascript" src="js/d3.v3.min.js"></script>
	<script lang="javascript" src="js/d3.v4.min.js"></script>
	<script lang="javascript" src="js/hierarchy.js"></script>
	<link rel="stylesheet" href="css/hierarchy.css">
</head>
<body>
	<div id="hierarchy1">
	</div>
	<div id="hierarchy2">
	</div>
	
	<script>
		/*
		 * Name1: Justin Jo
		 * Name2: Ivan Chen
		 * Name3: (if applicable) PARTNER'S NAME
		 */
		var width1 = d3.select("#hierarchy1").node().getBoundingClientRect().width,
			height1 = d3.select("#hierarchy1").node().getBoundingClientRect().height,
			width2 = d3.select("#hierarchy2").node().getBoundingClientRect().width,
			height2 = d3.select("#hierarchy2").node().getBoundingClientRect().height,
			radius = Math.min(width2, height2) / 2;

		var svg1 = d3.select("#hierarchy1").append("svg")
			.attr("id", "treemap")
		    .attr("width", width1)
		    .attr("height", height1);

		var svg2 = d3.select("#hierarchy2").append("svg")
		    .attr("width", width2)
		    .attr("height", height2)
		    .attr("id", "sunburst")
		  .append("g")
		    .attr("transform", "translate(" + width2 / 2 + "," + height2 * .52 + ")")
		    .attr("id", "sunburst-g");

		function ancestors(node) {
			var nodes = [node];
			while (node = node.parent) {
				nodes.push(node);
			}
			return nodes;
		}

		function findclass(node, sequenceArray) {
			var seqnode = sequenceArray[sequenceArray.length - 1];
			var runner = node;
			while (runner) {
				if (seqnode.id == runner.id) {
					return true;
				}
				runner = runner.parent;
			}
			return false;
		}



		var data = root;
			var fader = function(color) { return d3.interpolateRgb(color, "#fff")(0.2); },
			    color = d3.scaleOrdinal(d3.schemeCategory20.map(fader)),
			    format = d3.format(",d");

		function renderTreemap(data) {
			// append svg element
			svg1 = d3.select("#hierarchy1").append("svg")
				.attr("id", "treemap")
			    .attr("width", width1)
			    .attr("height", height1);



			var treemap = d3.treemap()
			    .tile(d3.treemapResquarify)
			    .size([width1, height1])
			    .round(true)
			    .paddingInner(1);

			var root = d3.hierarchy(data)
			  .eachBefore(function(d) { d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name; })
			  .sum(sumBySize)
			  .sort(function(a, b) { return b.height - a.height || b.value - a.value; });

			treemap(root);

			var cell = svg1.selectAll("g")
			.data(root.leaves())
			.enter().append("g")
			  .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

			cell.append("rect")
			  .attr("id", function(d) { return d.data.id; })
			  .attr("class", function(d) { return d.parent.data.id + '-c'})
			  .attr("width", function(d) { return d.x1 - d.x0; })
			  .attr("height", function(d) { return d.y1 - d.y0; })
			  .attr("fill", function(d) { return color(d.parent.data.id); })
			  .on("mouseover", mouseover);

			cell.append("clipPath")
			  .attr("id", function(d) { return "clip-" + d.data.id; })
			.append("use")
			  .attr("xlink:href", function(d) { return "#" + d.data.id; });

			cell.append("text")
			  .attr("clip-path", function(d) { return "url(#clip-" + d.data.id + ")"; })
			.selectAll("tspan")
			  .data(function(d) { return d.data.name.split(/(?=[A-Z][^A-Z])/g); })
			.enter().append("tspan")
			  .attr("x", 4)
			  .attr("y", function(d, i) { return 13 + i * 10; })
			  .text(function(d) { return d; });

			cell.append("title")
			  .text(function(d) { return d.data.id + "\n" + format(d.value); });

			d3.selectAll("input")
			  .data([sumBySize], function(d) { return d ? d.name : this.value; });


			function sumBySize(d) {
			  return d.size;
			}

						// Fade all but the current sequence, and show it in the breadcrumb trail.
			function mouseover(d) {
				console.log(d.data);
				var sequenceArray = ancestors(d).reverse();
				sequenceArray.shift(); // remove root node from the array
				var sequenceArr = ancestors(d.data).reverse();
				sequenceArr.shift();

				// Fade all the segments.
				d3.selectAll("rect")
				  .style("opacity", 0.3);
				d3.selectAll("path")
				  .style("opacity", 0.3);

				// Then highlight only those that are an ancestor of the current segment.
				d3.selectAll("rect")
				  .filter(function(node) {
				            return (sequenceArray.indexOf(node) >= 0) || (sequenceArr.indexOf(node) >= 0);
				          })
				  .style("opacity", 1);

				d3.selectAll("path")
				  .filter(function(node) {
				            return (sequenceArray.indexOf(node) >= 0) || (sequenceArr.indexOf(node) >= 0);
				          })
				  .style("opacity", 1);
			}

			function mouseleave(d) {
			  // Deactivate all segments during transition.
			  d3.selectAll("rect").on("mouseover", null);

			  // Transition each segment to full opacity and then reactivate it.
			  d3.selectAll("rect")
			      .transition()
			      .duration(500)
			      .style("opacity", 1)
			      .on("end", function() {
			              d3.select(this).on("mouseover", mouseover);
			            });
			}


			  // Add the mouseleave handler to the bounding circle.
			  d3.select("#treemap").on("mouseleave", mouseleave);
		}


		function renderSunburst(data) {
			svg2 = d3.select("#hierarchy2").append("svg")
			    .attr("width", width2)
			    .attr("height", height2)
			    .attr("id", "sunburst")
			  .append("g")
			    .attr("transform", "translate(" + width2 / 2 + "," + height2 * .52 + ")")
			    .attr("id", "sunburst-g");

			var partition = d3.layout.partition()
			    .sort(null)
			    .size([2 * Math.PI, radius * radius])
			    .value(function(d) { return 1; });

			var arc = d3.svg.arc()
			    .startAngle(function(d) { return d.x; })
			    .endAngle(function(d) { return d.x + d.dx; })
			    .innerRadius(function(d) { return Math.sqrt(d.y); })
			    .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });


			var path = svg2.datum(data).selectAll("path")
			  .data(partition.nodes)
			.enter().append("path")
			  .attr("display", function(d) { return d.depth ? null : "none"; }) // hide inner ring
			  .attr("d", arc)
			  .attr("id", function(d) {return d.name;})
			  .style("stroke", "#fff")
			  // .style("fill", function(d) { return color((d.children ? d : d.parent).name); })
  			  .style("fill", function(d) { return color((d.children ? d : d.parent).id); })

			  .style("fill-rule", "evenodd")
			  .each(stash)
			  .on("mouseover", mouseover);

			d3.selectAll("input").on("change", function change() {
			var value = this.value === "count"
			    ? function() { return 1; }
			    : function(d) { return d.size; };

			path
			    .data(partition.value(value).nodes)
			  .transition()
			    .duration(1500)
			    .attrTween("d", arcTween);
			});


			// Stash the old values for transition.
			function stash(d) {
			  d.x0 = d.x;
			  d.dx0 = d.dx;
			}

			// Interpolate the arcs in data space.
			function arcTween(a) {
			  var i = d3.interpolate({x: a.x0, dx: a.dx0}, a);
			  return function(t) {
			    var b = i(t);
			    a.x0 = b.x;
			    a.dx0 = b.dx;
			    return arc(b);
			  };
			}

			d3.select(self.frameElement).style("height", height2 + "px");


			// Fade all but the current sequence, and show it in the breadcrumb trail.
			function mouseover(d) {
				console.log(d);

				var sequenceArray = ancestors(d).reverse();
				sequenceArray.shift(); // remove root node from the array

				// Fade all the segments.
				d3.selectAll("path")
				  .style("opacity", 0.3);
				d3.selectAll("rect")
				  .style("opacity", 0.3);

				// Then highlight only those that are an ancestor of the current segment.
				d3.selectAll("path")
				    .filter(function(node) {
		          		return (sequenceArray.indexOf(node) >= 0);
		          	})
				    .style("opacity", 1);
				d3.selectAll("rect")
					.filter(function(node) {
						return (sequenceArray.indexOf(node.data) >= 0)
						|| findclass(node.data, sequenceArray);
					})
					.style("opacity", 1);
			}

			// Restore everything to full opacity when moving off the visualization.
			function mouseleave(d) {
			  // Deactivate all segments during transition.
			  d3.selectAll("path").on("mouseover", null);

				// Transition each segment to full opacity and then reactivate it.
				d3.selectAll("path")
					.transition()
					.duration(500)
					.style("opacity", 1)
					.on("end", function() {
						d3.select(this).on("mouseover", mouseover);
					});
			}


			// Add the mouseleave handler to the bounding circle.
			d3.select("#sunburst-g").on("mouseleave", mouseleave);
		}

		function render() {
			width1 = d3.select("#hierarchy1").node().getBoundingClientRect().width,
			height1 = d3.select("#hierarchy1").node().getBoundingClientRect().height,
			width2 = d3.select("#hierarchy2").node().getBoundingClientRect().width,
			height2 = d3.select("#hierarchy2").node().getBoundingClientRect().height;
			d3.select("#treemap").remove();
			d3.select("#sunburst").remove();
			renderTreemap(data);
			renderSunburst(data);
			console.log("render");
		}
		render();
		window.addEventListener("resize", render);
	</script>
</body>
</head>
</html>
